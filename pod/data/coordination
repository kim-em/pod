#!/usr/bin/env bash
# coordination â€” multi-agent coordination script (used by pod)
#
# All subcommands use `gh` CLI. Reads session UUID from $POD_SESSION_ID
# (exported by pod). Reads branch from git.
#
# Usage:
#   coordination orient                       â€” list open plans (claimed/unclaimed), PRs, issues needing attention
#   coordination plan [--label L] "title"     â€” create GitHub issue with agent-plan label (body from stdin); optional extra label L (feature|review|summarize|meditate)
#   coordination create-pr N [--partial] ["title"] â€” push branch, create PR closing issue #N, enable auto-merge; rejects PRs touching protected files
#   coordination claim-fix N                  â€” comment on failing PR #N claiming fix (30min cooldown)
#   coordination close-pr N "reason"          â€” comment reason and close PR #N
#   coordination list-unclaimed [--label L]   â€” list unclaimed agent-plan issues (FIFO order); optional label filter
#   coordination queue-depth [L]              â€” count of unclaimed agent-plan issues; optional label filter
#   coordination claim N                      â€” claim an issue for this session (label + comment)
#   coordination skip N "reason"              â€” mark a claimed issue as replan (stale/wrong assumptions)
#   coordination add-dep N M                  â€” add depends-on: #M to issue #N's body; add blocked label if #M is open
#   coordination check-blocked                â€” unblock issues whose dependencies are all closed
#   coordination release-stale-claims [SECS]  â€” release claimed issues with no activity for SECS seconds (default 14400 = 4h)
#   coordination lock-planner                 â€” acquire advisory planner lock (20min TTL)
#   coordination unlock-planner               â€” release planner lock early

set -euo pipefail

REPO="$(gh repo view --json nameWithOwner -q .nameWithOwner 2>/dev/null)" \
    || { echo "error: cannot detect GitHub repo (is gh authenticated?)" >&2; exit 1; }
REPO_SLUG="${REPO//\//-}"  # e.g. "owner-repo"
BASE_BRANCH="$(gh repo view --json defaultBranchRef -q .defaultBranchRef.name 2>/dev/null || echo master)"
SESSION_ID="${POD_SESSION_ID:-unknown}"
BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo detached)"
PLANNER_LOCK_TTL=1200   # lock expires after 20 minutes (seconds)
PLANNER_LOCK_COMMENT_FILE="/tmp/pod-planner-lock-${REPO_SLUG}-${SESSION_ID}.id"

# Protected files: agents are forbidden from modifying these in PRs.
# Reads from $POD_PROTECTED_FILES (colon-separated, set by pod from config).
# Falls back to PLAN.md if unset.
PROTECTED_FILES="${POD_PROTECTED_FILES:-PLAN.md}"

# Planner lock sentinel issue â€” auto-detected or auto-created.
# Caches the issue number in /tmp to avoid repeated API calls.
_planner_lock_issue_cache="/tmp/pod-planner-lock-issue-${REPO_SLUG}"
_resolve_planner_lock_issue() {
    # Check cache first; validate the issue still exists and is open
    if [[ -f "$_planner_lock_issue_cache" ]]; then
        local cached
        cached="$(cat "$_planner_lock_issue_cache")"
        local state
        state="$(gh issue view "$cached" --repo "$REPO" --json state --jq .state 2>/dev/null || true)"
        if [[ "$state" == "OPEN" ]]; then
            PLANNER_LOCK_ISSUE="$cached"
            return
        fi
        # Stale cache â€” remove and re-resolve
        rm -f "$_planner_lock_issue_cache"
    fi
    # Search for existing sentinel issue
    local issue_num
    issue_num="$(gh issue list --repo "$REPO" --state open --search 'pod: planner lock sentinel' \
        --json number,title --jq '.[] | select(.title == "pod: planner lock sentinel") | .number' \
        | head -1)"
    if [[ -z "$issue_num" ]]; then
        # Create the sentinel issue
        issue_num="$(gh issue create --repo "$REPO" \
            --title "pod: planner lock sentinel" \
            --body "This issue is used by pod for advisory planner locking. Do not close or modify." \
            --json number --jq '.number')"
        # Pin it if possible (ignore failure â€” not all repos allow pinning)
        gh issue pin "$issue_num" --repo "$REPO" 2>/dev/null || true
    fi
    echo "$issue_num" > "$_planner_lock_issue_cache"
    PLANNER_LOCK_ISSUE="$issue_num"
}

die() { echo "error: $*" >&2; exit 1; }

# Verify gh CLI is authenticated
gh auth status --hostname github.com >/dev/null 2>&1 || \
    die "gh CLI not authenticated â€” run 'gh auth login' first"

# Helper: get unclaimed issues as JSON array
# Optional arg: extra label to filter by (e.g. "feature", "review")
_unclaimed_issues() {
    local extra_label="${1:-}"
    local -a label_args=("--label" "agent-plan")
    [[ -n "$extra_label" ]] && label_args+=("--label" "$extra_label")
    gh issue list --repo "$REPO" "${label_args[@]}" --state open --limit 50 \
        --json number,title,labels,createdAt \
        --jq '[.[] | select(.labels | all(.name != "claimed") and all(.name != "blocked") and all(.name != "has-pr") and all(.name != "replan"))] |
              sort_by(.createdAt)'
}

# --- orient ---
cmd_orient() {
    echo "=== Unclaimed work items ==="
    _unclaimed_issues | jq -r '.[] | "#\(.number) \(.title) (\(.createdAt[:16]))"'

    echo ""
    echo "=== Blocked issues ==="
    local open_nums
    open_nums="$(gh issue list --repo "$REPO" --state open --limit 100 --json number --jq '[.[].number]')"
    gh issue list --repo "$REPO" --label agent-plan --label blocked --state open --limit 50 \
        --json number,title,body \
    | jq -r --argjson open "$open_nums" \
        '.[] | "#\(.number) [Blocked on \([.body | match("depends-on: #([0-9]+)"; "g") | .captures[0].string | tonumber | . as $d | if ($open | index($d) != null) then "#\($d)" else empty end] | join(", "))] \(.title)"'

    echo ""
    echo "=== Claimed work items ==="
    gh issue list --repo "$REPO" --label agent-plan --label claimed --state open --limit 20 \
        --json number,title,createdAt \
        --template '{{range .}}#{{.number}} {{.title}} ({{timeago .createdAt}}){{"\n"}}{{end}}'

    echo ""
    echo "=== Issues with open PRs ==="
    gh issue list --repo "$REPO" --label agent-plan --label has-pr --state open --limit 20 \
        --json number,title,createdAt \
        --template '{{range .}}#{{.number}} {{.title}} ({{timeago .createdAt}}){{"\n"}}{{end}}'

    echo ""
    echo "=== Open pull requests ==="
    gh pr list --repo "$REPO" --state open --limit 20 \
        --json number,title,headRefName,statusCheckRollup,labels,mergeable \
        --jq '.[] | "#\(.number) [\(.headRefName)] \(.title)\(.labels | map(" (\(.name))") | join(""))\(if ((.labels | any(.name == "merge-conflict")) or .mergeable == "CONFLICTING") then " \u001b[31m[CONFLICTS]\u001b[0m" else "" end)\(if (.statusCheckRollup | any(.conclusion == "FAILURE")) then " âœ—CI" else "" end)"'

    echo ""
    echo "=== PRs needing attention (failing CI, merge-conflict, or dirty) ==="
    gh pr list --repo "$REPO" --state open --limit 20 \
        --json number,title,labels,mergeable,statusCheckRollup \
        --jq '[.[] | select(
            (.labels | any(.name == "merge-conflict")) or
            (.mergeable == "CONFLICTING") or
            (.statusCheckRollup | any(.conclusion == "FAILURE"))
        )] | .[] | "#\(.number) \(.title)\(if ((.labels | any(.name == "merge-conflict")) or .mergeable == "CONFLICTING") then " \u001b[31m[CONFLICTS]\u001b[0m" else "" end)\(if (.statusCheckRollup | any(.conclusion == "FAILURE")) then " [CI FAILED]" else "" end)"'
}

# --- plan ---
cmd_plan() {
    local extra_label=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label) extra_label="${2:?--label requires a value}"; shift 2 ;;
            *) break ;;
        esac
    done
    local title="${1:?usage: coordination plan [--label L] \"title\"}"

    # Fetch all open agent-plan issues with full bodies for overlap detection
    local existing_json
    existing_json="$(gh issue list --repo "$REPO" --label agent-plan --state open --limit 50 \
        --json number,title,body)"

    # Warn if any existing issue title shares significant keywords with the new title
    local existing_titles
    existing_titles="$(echo "$existing_json" | jq -r '.[].title')"
    if [[ -n "$existing_titles" ]]; then
        # Extract key words (>4 chars) from the new title and check overlap
        local keywords
        keywords="$(echo "$title" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alpha:]' '\n' | \
            awk 'length > 4' | sort -u)"
        local overlap_found=false
        while IFS= read -r existing_title; do
            local existing_lower
            existing_lower="$(echo "$existing_title" | tr '[:upper:]' '[:lower:]')"
            local match_count=0
            local total_keywords=0
            while IFS= read -r kw; do
                [[ -z "$kw" ]] && continue
                total_keywords=$((total_keywords + 1))
                if echo "$existing_lower" | grep -qi "$kw"; then
                    match_count=$((match_count + 1))
                fi
            done <<< "$keywords"
            if [[ "$total_keywords" -gt 0 && "$match_count" -ge 2 ]]; then
                if [[ "$overlap_found" == false ]]; then
                    echo "warning: potentially overlapping open issues found:"
                    overlap_found=true
                fi
                echo "  - $existing_title"
            fi
        done <<< "$existing_titles"
        if [[ "$overlap_found" == true ]]; then
            echo "Proceeding anyway..."
        fi
    fi

    local body
    body="$(cat)"

    # Check for depends-on lines before creating the issue
    local create_labels="agent-plan"
    [[ -n "$extra_label" ]] && create_labels="$create_labels,$extra_label"
    local deps
    deps="$(echo "$body" | grep -oE 'depends-on: #[0-9]+' | grep -oE '[0-9]+' || true)"
    if [[ -n "$deps" ]]; then
        local has_open_dep=false
        while read -r dep_num; do
            [[ -z "$dep_num" ]] && continue
            local dep_state
            dep_state="$(gh issue view "$dep_num" --repo "$REPO" --json state --jq .state 2>/dev/null || echo UNKNOWN)"
            if [[ "$dep_state" != "CLOSED" ]]; then
                has_open_dep=true
                break
            fi
        done <<< "$deps"
        if [[ "$has_open_dep" == true ]]; then
            create_labels="$create_labels,blocked"
        fi
    fi

    local issue_url
    issue_url="$(gh issue create --repo "$REPO" \
        --title "$title" \
        --label "$create_labels" \
        --body "$body")"

    # Extract issue number from the URL returned by gh issue create
    local issue_num
    issue_num="${issue_url##*/}"

    if [[ "$create_labels" == *"blocked"* ]]; then
        echo "Created issue #$issue_num: $title (blocked â€” depends on open issue(s))"
    else
        echo "Created issue #$issue_num: $title"
    fi

    if [[ -n "$issue_num" ]]; then
        gh issue comment "$issue_num" --repo "$REPO" \
            --body "Session: \`$SESSION_ID\` Branch: \`$BRANCH\`"
    fi
}

# --- create-pr ---
cmd_create_pr() {
    # Parse arguments: create-pr N [--partial] ["custom title"]
    local issue_num="${1:?usage: coordination create-pr N [--partial] [\"custom title\"]}"
    shift
    local partial=false
    local custom_title=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --partial) partial=true; shift ;;
            *) custom_title="$1"; shift ;;
        esac
    done

    # Guard: refuse to create PR from master or detached HEAD
    if [[ "$BRANCH" == "master" || "$BRANCH" == "main" || "$BRANCH" == "detached" ]]; then
        die "cannot create PR from branch '$BRANCH' â€” use an agent/* branch"
    fi

    # Determine PR title: custom if provided, otherwise from issue
    local pr_title
    if [[ -n "$custom_title" ]]; then
        pr_title="$custom_title"
    else
        pr_title="$(gh issue view "$issue_num" --repo "$REPO" --json title --jq .title)"
    fi

    # Determine issue reference line
    local issue_ref
    if [[ "$partial" == true ]]; then
        issue_ref="Partial progress on #$issue_num"
    else
        issue_ref="Closes #$issue_num"
    fi

    # Protect immutable files â€” reject PRs that introduce changes to protected files.
    # Use merge-base (three-dot) diff so we only see what THIS BRANCH added, not upstream changes.
    local merge_base touched_protected
    merge_base="$(git merge-base "origin/$BASE_BRANCH" HEAD 2>/dev/null || true)"
    if [[ -n "$merge_base" && -n "$PROTECTED_FILES" ]]; then
        # Convert colon-separated list to arguments
        local -a pf_args=()
        IFS=: read -ra pf_args <<< "$PROTECTED_FILES"
        touched_protected="$(git diff --name-only "$merge_base" HEAD -- "${pf_args[@]}" 2>/dev/null || true)"
        if [[ -n "$touched_protected" ]]; then
            die "This PR touches protected files ($touched_protected). These files are off-limits to agents. Aborting PR creation."
        fi
    fi

    # Push branch
    git push -u origin "$BRANCH"

    # Check if PR already exists for this branch
    local existing_pr
    existing_pr="$(gh pr list --repo "$REPO" --head "$BRANCH" --json number --jq '.[0].number // empty')"
    if [[ -n "$existing_pr" ]]; then
        echo "PR #$existing_pr already exists for branch $BRANCH. Enabling auto-merge."
        gh pr merge "$existing_pr" --repo "$REPO" --auto --squash || \
            echo "warning: auto-merge not available (branch protection may not be set up)"
        if [[ "$partial" == true ]]; then
            # Partial: add replan BEFORE removing claimed to prevent race window
            gh issue edit "$issue_num" --repo "$REPO" --add-label replan 2>/dev/null || true
            gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed 2>/dev/null || true
            echo "Issue #$issue_num marked replan (partial completion)"
        else
            gh issue edit "$issue_num" --repo "$REPO" --add-label has-pr 2>/dev/null || true
            gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed 2>/dev/null || true
        fi
        return 0
    fi

    # Create PR
    gh pr create --repo "$REPO" \
        --head "$BRANCH" \
        --title "$pr_title" \
        --body "$(cat <<EOF
$issue_ref

Session: \`$SESSION_ID\`

$(git log "origin/$BASE_BRANCH..HEAD" --oneline)

ðŸ¤– Prepared with Claude Code
EOF
)"

    # Enable auto-merge
    local pr_num
    pr_num="$(gh pr list --repo "$REPO" --head "$BRANCH" --json number --jq '.[0].number')"
    if [[ -n "$pr_num" ]]; then
        gh pr merge "$pr_num" --repo "$REPO" --auto --squash || \
            echo "warning: auto-merge not available (branch protection may not be set up)"
    fi

    # Update issue labels â€” add new label BEFORE removing claimed to prevent race window
    if [[ "$partial" == true ]]; then
        # Partial: replan so planner can re-scope before another worker claims
        gh issue edit "$issue_num" --repo "$REPO" --add-label replan 2>/dev/null || true
        gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed 2>/dev/null || true
        echo "Issue #$issue_num marked replan (partial completion)"
    else
        # Full: claimed â†’ has-pr
        gh issue edit "$issue_num" --repo "$REPO" --add-label has-pr 2>/dev/null || true
        gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed 2>/dev/null || true
    fi
}

# --- claim-fix ---
# NOTE: claim-fix is best-effort advisory, not strict mutual exclusion.
# Two agents may both claim the same PR in a narrow race window.
# Branch protection serializes the actual merges, so worst case is
# duplicate work, not corruption.
cmd_claim_fix() {
    local pr_num="${1:?usage: coordination claim-fix N}"

    # Check for recent claims (last 30 minutes)
    local recent_claim
    recent_claim="$(gh api --paginate "repos/$REPO/issues/$pr_num/comments" \
        --jq '[.[] | select(.body | test("Session .* attempting fix")) |
               select(.created_at > (now - 1800 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
               length')"

    if [[ "$recent_claim" -gt 0 ]]; then
        echo "Another session claimed this PR in the last 30 minutes. Skipping."
        return 1
    fi

    gh issue comment "$pr_num" --repo "$REPO" \
        --body "Session \`$SESSION_ID\` attempting fix on branch \`$BRANCH\`"
}

# --- close-pr ---
cmd_close_pr() {
    local pr_num="${1:?usage: coordination close-pr N \"reason\"}"
    local reason="${2:?usage: coordination close-pr N \"reason\"}"

    gh pr close "$pr_num" --repo "$REPO" \
        --comment "$reason (Session: \`$SESSION_ID\`)"

    # Remove has-pr from any linked issue so it becomes claimable again
    local linked_issue
    linked_issue="$(gh pr view "$pr_num" --repo "$REPO" --json body --jq '.body' | \
        grep -oE 'Closes #[0-9]+' | grep -oE '[0-9]+' | head -1)"
    if [[ -n "$linked_issue" ]]; then
        gh issue edit "$linked_issue" --repo "$REPO" --remove-label has-pr 2>/dev/null || true
    fi
}

# --- list-unclaimed ---
cmd_list_unclaimed() {
    local extra_label=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label) extra_label="${2:?--label requires a value}"; shift 2 ;;
            *) break ;;
        esac
    done
    _unclaimed_issues "$extra_label" | jq -r '.[] | "#\(.number) \(.title) (\(.createdAt[:16]))"'
}

# --- queue-depth ---
# Accepts either positional label (used internally by pod) or --label L (consistent with list-unclaimed)
cmd_queue_depth() {
    local extra_label=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label) extra_label="${2:?--label requires a value}"; shift 2 ;;
            *) extra_label="$1"; shift ;;   # positional label for backward compat
        esac
    done
    _unclaimed_issues "$extra_label" | jq 'length'
}

# --- claim ---
# Claim an issue for this session. Uses label + comment.
# Returns 0 on success, 1 if already claimed or race detected.
cmd_claim() {
    local issue_num="${1:?usage: coordination claim N}"

    # Check if already claimed
    local labels
    labels="$(gh issue view "$issue_num" --repo "$REPO" --json labels --jq '[.labels[].name] | join(",")')"
    if echo "$labels" | grep -qw 'claimed'; then
        echo "Issue #$issue_num is already claimed. Skipping."
        return 1
    fi
    if echo "$labels" | grep -qw 'replan'; then
        echo "Issue #$issue_num needs replan. Skipping."
        return 1
    fi
    if echo "$labels" | grep -qw 'blocked'; then
        echo "Issue #$issue_num is blocked by dependencies. Skipping."
        return 1
    fi
    if echo "$labels" | grep -qw 'has-pr'; then
        echo "Issue #$issue_num already has an open PR. Skipping."
        return 1
    fi

    # Claim: add label + comment
    local is_resume="${POD_IS_RESUME:-0}"
    local claim_note=""
    [[ "$is_resume" == "1" ]] && claim_note=" (resumed conversation)"
    gh issue edit "$issue_num" --repo "$REPO" --add-label claimed
    gh issue comment "$issue_num" --repo "$REPO" \
        --body "Claimed by session \`$SESSION_ID\` on branch \`$BRANCH\`${claim_note}"

    # Race detection: wait briefly, then check for multiple recent claims
    sleep 2
    local recent_claims
    recent_claims="$(gh api --paginate "repos/$REPO/issues/$issue_num/comments" \
        --jq '[.[] | select(.body | test("Claimed by session")) |
               select(.created_at > (now - 60 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
               length')"

    if [[ "$recent_claims" -gt 1 ]]; then
        # Race detected â€” lowest UUID wins
        local winner
        winner="$(gh api --paginate "repos/$REPO/issues/$issue_num/comments" \
            --jq '[.[] | select(.body | test("Claimed by session")) |
                   select(.created_at > (now - 60 | strftime("%Y-%m-%dT%H:%M:%SZ")))] |
                   sort_by(.body) | .[0].body |
                   match("session `([^`]+)`") | .captures[0].string')"

        if [[ "$winner" != "$SESSION_ID" ]]; then
            echo "Race detected on #$issue_num â€” session $winner won. Backing off."
            # Do NOT remove the 'claimed' label â€” the winner needs it
            return 1
        fi
        echo "Race detected on #$issue_num â€” this session won."
    fi

    echo "Claimed issue #$issue_num"
}

# --- skip ---
# Mark a claimed issue as needing replan (stale plan, wrong assumptions, etc.).
cmd_skip() {
    local issue_num="${1:?usage: coordination skip N \"reason\"}"
    local reason="${2:?usage: coordination skip N \"reason\"}"

    gh issue edit "$issue_num" --repo "$REPO" --remove-label claimed --add-label replan
    gh issue comment "$issue_num" --repo "$REPO" \
        --body "Skipped by session \`$SESSION_ID\` (needs replan): $reason"
    echo "Skipped issue #$issue_num (marked replan): $reason"
}

# --- lock-planner ---
# Advisory lock to prevent concurrent planner sessions.
# Uses comments on the sentinel issue as tickets: each agent posts a comment
# with its session ID, then checks whether its comment has the lowest ID
# among all active (within-TTL) lock-attempt comments.
# Lowest ID = posted first = lock winner. All agents share one GitHub account
# so reactions/labels can't distinguish them; comment IDs are unique.
# TTL is measured using server-side created_at, not agent clocks.
# The winning comment ID is persisted to a temp file for use by unlock.
# Returns 0 if lock acquired, 1 if another planner is active.
cmd_lock_planner() {
    _resolve_planner_lock_issue
    local now
    now="$(date -u +%s)"
    local cutoff=$(( now - PLANNER_LOCK_TTL ))

    # 1. Post a lock-attempt comment (gets a unique, monotonically increasing ID)
    local my_id
    my_id="$(gh api "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/comments" \
        -X POST -f body="planner-lock-attempt: $SESSION_ID" \
        --jq '.id')"

    # 2. Brief pause so concurrent attempts land before we read
    sleep 3

    # 3. Find the lowest comment ID among all active lock-attempt comments.
    #    Use server-side created_at for TTL (avoids agent clock skew).
    local earliest_id
    earliest_id="$(gh api --paginate "repos/$REPO/issues/$PLANNER_LOCK_ISSUE/comments" \
        --jq "[.[] | select(.body | startswith(\"planner-lock-attempt:\")) |
               select((.created_at | fromdateiso8601) > $cutoff) |
               .id] | min // empty")"

    if [[ -n "$earliest_id" && "$my_id" -eq "$earliest_id" ]]; then
        # Persist comment ID so unlock can delete it directly
        echo "$my_id" > "$PLANNER_LOCK_COMMENT_FILE"
        echo "Planner lock acquired (comment #$my_id)"
        return 0
    else
        # Lost the race (or no active attempts found) â€” clean up and bail
        gh api "repos/$REPO/issues/comments/$my_id" -X DELETE 2>/dev/null || true
        echo "Another planner is active (lock held by comment #${earliest_id:-unknown}). Skipping."
        return 1
    fi
}

# --- unlock-planner ---
# Release the planner lock by deleting the exact comment created at lock time.
cmd_unlock_planner() {
    local my_id=""
    if [[ -f "$PLANNER_LOCK_COMMENT_FILE" ]]; then
        my_id="$(cat "$PLANNER_LOCK_COMMENT_FILE")"
        rm -f "$PLANNER_LOCK_COMMENT_FILE"
    fi
    if [[ -n "$my_id" ]]; then
        gh api "repos/$REPO/issues/comments/$my_id" -X DELETE 2>/dev/null || true
        echo "Planner lock released (deleted comment #$my_id)"
    else
        echo "No lock comment ID found; nothing to release"
    fi
}

# --- add-dep ---
# Add a depends-on: #M line to issue #N's body (if not already present),
# then add the blocked label if #M is open.
# Use this whenever a new dependency is discovered on an existing issue â€”
# it keeps the body authoritative so check-blocked can unblock automatically.
cmd_add_dep() {
    local issue_num="${1:?usage: coordination add-dep <issue> <dep>}"
    local dep_num="${2:?usage: coordination add-dep <issue> <dep>}"

    local body
    body="$(gh issue view "$issue_num" --repo "$REPO" --json body --jq .body)"

    if echo "$body" | grep -qE "depends-on: #${dep_num}([^0-9]|$)"; then
        echo "Issue #$issue_num already has depends-on: #$dep_num in its body"
    else
        gh issue edit "$issue_num" --repo "$REPO" --body "${body}
depends-on: #${dep_num}"
        echo "Added depends-on: #$dep_num to body of issue #$issue_num"
    fi

    local dep_state
    dep_state="$(gh issue view "$dep_num" --repo "$REPO" --json state --jq .state)"
    if [[ "$dep_state" == "OPEN" ]]; then
        gh issue edit "$issue_num" --repo "$REPO" --add-label blocked
        echo "Added blocked label (dependency #$dep_num is open)"
    else
        echo "Dependency #$dep_num is already closed; blocked label not added"
    fi
}

# --- check-blocked ---
# Scan blocked issues and unblock those whose dependencies are all closed.
# --- release-stale-claims ---
# Release claimed issues whose claim comment is older than a threshold.
# Called periodically by pod. Workers that die without releasing their
# claim (crash, OOM, SIGKILL) are detected and their issues freed.
cmd_release_stale_claims() {
    local stale_secs="${1:-14400}"  # default: 4 hours
    local now
    now="$(date -u +%s)"

    gh issue list --repo "$REPO" --label claimed --state open --limit 50 \
        --json number,title | jq -c '.[]' | \
    while read -r issue_json; do
        local num title
        num="$(echo "$issue_json" | jq -r '.number')"
        title="$(echo "$issue_json" | jq -r '.title')"

        # Find timestamp of most recent "Claimed by session" comment
        local claim_ts
        claim_ts="$(gh issue view "$num" --repo "$REPO" --json comments \
            --jq '[.comments[] | select(.body | startswith("Claimed by session"))] | last | .createdAt // ""')"

        [[ -z "$claim_ts" ]] && continue

        local claim_epoch
        claim_epoch="$(date -d "$claim_ts" +%s 2>/dev/null || echo 0)"
        local age=$(( now - claim_epoch ))

        if [[ $age -gt $stale_secs ]]; then
            local age_str
            age_str="$(( age / 3600 ))h$(( (age % 3600) / 60 ))m"
            gh issue edit "$num" --repo "$REPO" --remove-label claimed
            gh issue comment "$num" --repo "$REPO" \
                --body "Stale claim released â€” worker session appears to have died (claimed ${age_str} ago). Available for reclaim."
            echo "Released stale claim on #$num ($title, age ${age_str})"
        fi
    done
}

cmd_check_blocked() {
    local issues
    issues="$(gh issue list --repo "$REPO" --label blocked --state open --limit 50 \
        --json number,body)"

    echo "$issues" | jq -c '.[]' | \
    while read -r issue_json; do
        local num body
        num="$(echo "$issue_json" | jq -r '.number')"
        body="$(echo "$issue_json" | jq -r '.body')"

        local deps
        deps="$(echo "$body" | grep -oE 'depends-on: #[0-9]+' | grep -oE '[0-9]+' || true)"
        [[ -z "$deps" ]] && continue

        local all_closed=true
        while read -r dep_num; do
            [[ -z "$dep_num" ]] && continue
            local dep_state
            dep_state="$(gh issue view "$dep_num" --repo "$REPO" --json state --jq .state 2>/dev/null || echo UNKNOWN)"
            if [[ "$dep_state" != "CLOSED" ]]; then
                all_closed=false
                break
            fi
        done <<< "$deps"

        if [[ "$all_closed" == true ]]; then
            gh issue edit "$num" --repo "$REPO" --remove-label blocked
            echo "Unblocked issue #$num (all dependencies resolved)"
        fi
    done
}

# --- dispatch ---
case "${1:-}" in
    orient)          cmd_orient ;;
    plan)            shift; cmd_plan "$@" ;;
    create-pr)       shift; cmd_create_pr "$@" ;;
    claim-fix)       shift; cmd_claim_fix "$@" ;;
    close-pr)        shift; cmd_close_pr "$@" ;;
    list-unclaimed)  shift; cmd_list_unclaimed "$@" ;;
    queue-depth)     shift; cmd_queue_depth "$@" ;;
    claim)           shift; cmd_claim "$@" ;;
    skip)            shift; cmd_skip "$@" ;;
    add-dep)                shift; cmd_add_dep "$@" ;;
    check-blocked)          cmd_check_blocked ;;
    release-stale-claims)   shift; cmd_release_stale_claims "$@" ;;
    lock-planner)           cmd_lock_planner ;;
    unlock-planner)         cmd_unlock_planner ;;
    *)               die "unknown command: ${1:-}
Usage: coordination {orient|plan [--label L]|create-pr|claim-fix|close-pr|list-unclaimed [--label L]|queue-depth [L]|claim|skip|add-dep|check-blocked|release-stale-claims|lock-planner|unlock-planner}" ;;
esac
